import {
  Form,
  ActionPanel,
  Action,
  showToast,
  Toast,
  getPreferenceValues,
  showInFinder,
  popToRoot,
  open,
} from "@raycast/api";
import { useForm, FormValidation } from "@raycast/utils";
import { useState, useEffect } from "react";
import fetch from "node-fetch";
import { JSDOM } from "jsdom";
import { Readability } from "@mozilla/readability";
import * as fs from "fs-extra";
import * as path from "path";
import * as crypto from "crypto";
import { createTurndownService } from "./turndown-config";
import { 
  sanitizeFilename, 
  generateFilenameFromTitle, 
  ensureUniqueFilename,
  extractDomain,
  handleError 
} from "./utils";
import { Preferences } from "./preferences";

interface FormValues {
  url: string;
  removeNonContent: boolean;
  downloadImages: boolean;
  outputPath: string;
  filename: string;
  autoGenerateFilename: boolean;
  openAfterConversion: boolean;
}

export default function ConvertWebpage() {
  const [isLoading, setIsLoading] = useState(false);
  const [suggestedFilename, setSuggestedFilename] = useState("");
  const preferences = getPreferenceValues<Preferences>();

  const { handleSubmit, itemProps, values } = useForm<FormValues>({
    onSubmit: async (values) => {
      setIsLoading(true);
      try {
        await convertWebpageToMarkdown(values);
      } catch (error) {
        await handleError(error, "Webpage Conversion");
      } finally {
        setIsLoading(false);
      }
    },
    validation: {
      url: FormValidation.Required,
      outputPath: FormValidation.Required,
      filename: (value) => {
        if (!values.autoGenerateFilename && !value) {
          return "Filename is required when auto-generate is disabled";
        }
      },
    },
    initialValues: {
      outputPath: preferences.defaultOutputPath || path.join(process.env.HOME || "", "Downloads"),
      removeNonContent: true,
      downloadImages: true,
      autoGenerateFilename: true,
      openAfterConversion: false,
    },
  });

  // Update suggested filename when URL changes
  useEffect(() => {
    if (values.url && values.autoGenerateFilename) {
      try {
        const url = new URL(values.url);
        const domain = extractDomain(values.url);
        const pathParts = url.pathname.split("/").filter(p => p);
        const lastPart = pathParts[pathParts.length - 1] || domain;
        const cleanName = sanitizeFilename(lastPart.replace(/\.\w+$/, ""));
        setSuggestedFilename(`${cleanName}.md`);
      } catch {
        setSuggestedFilename("webpage.md");
      }
    }
  }, [values.url, values.autoGenerateFilename]);

  async function convertWebpageToMarkdown(values: FormValues) {
    const toast = await showToast({
      style: Toast.Style.Animated,
      title: "Converting webpage...",
    });

    // Validate URL
    let url: URL;
    try {
      url = new URL(values.url);
    } catch {
      throw new Error("Invalid URL provided");
    }

    // Fetch the webpage
    toast.message = "Fetching webpage...";
    const response = await fetch(values.url, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch webpage: ${response.status} ${response.statusText}`);
    }

    const html = await response.text();
    const baseUrl = new URL(values.url);

    // Parse HTML with JSDOM
    toast.message = "Parsing content...";
    const dom = new JSDOM(html, { url: values.url });
    const document = dom.window.document;

    let content: string;
    let title = document.title || "Untitled";
    let articleContent: Element | null = null;

    if (values.removeNonContent) {
      // Use Readability to extract main content
      const reader = new Readability(document);
      const article = reader.parse();

      if (!article) {
        // Fallback: try to find main content manually
        articleContent = 
          document.querySelector("main") ||
          document.querySelector("article") ||
          document.querySelector("[role='main']") ||
          document.querySelector(".content") ||
          document.querySelector("#content") ||
          document.body;
      } else {
        // Create a new document with just the article content
        const cleanDom = new JSDOM(article.content);
        articleContent = cleanDom.window.document.body;
        title = article.title || title;
      }
    } else {
      // Convert the entire body
      articleContent = document.body;
    }

    // Create output directory if it doesn't exist
    await fs.ensureDir(values.outputPath);

    // Process images if needed
    let imagesFolder: string | null = null;
    if (values.downloadImages && articleContent) {
      toast.message = "Downloading images...";
      imagesFolder = await processImages(
        articleContent, 
        baseUrl, 
        values.outputPath,
        sanitizeFilename(title)
      );
    }

    // Convert to markdown
    toast.message = "Converting to markdown...";
    const turndownService = createTurndownService();
    content = articleContent ? turndownService.turndown(articleContent) : "";

    // Generate filename
    let filename: string;
    if (values.autoGenerateFilename) {
      filename = generateFilenameFromTitle(title);
    } else {
      filename = values.filename.endsWith(".md") 
        ? values.filename 
        : `${values.filename}.md`;
    }
    
    let outputFile = path.join(values.outputPath, filename);
    outputFile = await ensureUniqueFilename(outputFile);

    // Add metadata header
    const metadata = `---
title: ${title}
url: ${values.url}
date: ${new Date().toISOString()}
domain: ${extractDomain(values.url)}
${imagesFolder ? `images_folder: ${path.basename(imagesFolder)}` : ""}
---

`;

    // Clean up the content
    content = content
      .replace(/\n{3,}/g, "\n\n") // Remove excessive newlines
      .trim();

    // Write the markdown file
    await fs.writeFile(outputFile, metadata + content);

    toast.style = Toast.Style.Success;
    toast.title = "Conversion Complete";
    toast.message = `Saved to ${path.basename(outputFile)}`;
    toast.primaryAction = {
      title: "Show in Finder",
      onAction: () => {
        showInFinder(outputFile);
      },
    };
    toast.secondaryAction = {
      title: "Open File",
      onAction: () => {
        open(outputFile);
      },
    };

    if (values.openAfterConversion) {
      await open(outputFile);
    }

    await popToRoot();
  }

  async function processImages(
    element: Element, 
    baseUrl: URL, 
    outputPath: string,
    folderPrefix: string
  ): Promise<string | null> {
    const images = element.querySelectorAll("img");
    if (images.length === 0) return null;

    const timestamp = new Date().toISOString().split("T")[0];
    const imageDir = path.join(outputPath, `${folderPrefix}-images-${timestamp}`);
    await fs.ensureDir(imageDir);

    let downloadedCount = 0;
    
    for (const img of images) {
      try {
        const src = img.getAttribute("src");
        if (!src) continue;

        const imageUrl = new URL(src, baseUrl);
        
        // Skip data URLs and invalid protocols
        if (imageUrl.protocol === "data:" || 
            (!imageUrl.protocol.startsWith("http") && 
             !imageUrl.protocol.startsWith("https"))) {
          continue;
        }

        // Download image
        const response = await fetch(imageUrl.href, {
          headers: {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
          },
        });
        
        if (!response.ok) continue;

        const buffer = await response.buffer();
        
        // Determine file extension
        const contentType = response.headers.get("content-type");
        let ext = path.extname(imageUrl.pathname) || "";
        
        if (!ext && contentType) {
          const typeMap: Record<string, string> = {
            "image/jpeg": ".jpg",
            "image/png": ".png",
            "image/gif": ".gif",
            "image/webp": ".webp",
            "image/svg+xml": ".svg",
          };
          ext = typeMap[contentType] || ".jpg";
        } else if (!ext) {
          ext = ".jpg";
        }
        
        // Generate unique filename
        const hash = crypto.createHash("md5").update(imageUrl.href).digest("hex").substring(0, 8);
        const imgTitle = img.getAttribute("alt") || img.getAttribute("title") || "image";
        const cleanTitle = sanitizeFilename(imgTitle).substring(0, 50);
        const filename = `${cleanTitle}-${hash}${ext}`;
        const localPath = path.join(imageDir, filename);

        // Save image
        await fs.writeFile(localPath, buffer);
        downloadedCount++;

        // Update image src to relative path
        const relativePath = `${path.basename(imageDir)}/${filename}`;
        img.setAttribute("src", relativePath);
        
        // Add alt text if missing
        if (!img.getAttribute("alt")) {
          img.setAttribute("alt", imgTitle);
        }
      } catch (error) {
        console.error(`Failed to download image ${src}:`, error);
      }
    }

    return downloadedCount > 0 ? imageDir : null;
  }

  return (
    <Form
      isLoading={isLoading}
      actions={
        <ActionPanel>
          <Action.SubmitForm title="Convert to Markdown" onSubmit={handleSubmit} />
          <Action.OpenInBrowser url="https://github.com/danielmarass/webpage-to-markdown" />
        </ActionPanel>
      }
    >
      <Form.TextField
        title="URL"
        placeholder="https://example.com/article"
        info="The webpage URL to convert to markdown"
        {...itemProps.url}
      />
      
      <Form.Checkbox
        label="Auto-generate filename from title"
        info="Automatically create a filename based on the page title"
        {...itemProps.autoGenerateFilename}
      />
      
      {!values.autoGenerateFilename && (
        <Form.TextField
          title="Filename"
          placeholder={suggestedFilename || "article.md"}
          info="Name for the markdown file (extension will be added automatically)"
          {...itemProps.filename}
        />
      )}
      
      <Form.TextField
        title="Output Path"
        placeholder="/Users/username/Documents"
        info="Directory where the markdown file will be saved"
        {...itemProps.outputPath}
      />
      
      <Form.Separator />
      
      <Form.Description text="Conversion Options" />
      
      <Form.Checkbox
        label="Remove non-content elements"
        info="Extract only the main article content, removing ads, navigation, etc."
        {...itemProps.removeNonContent}
      />
      
      <Form.Checkbox
        label="Download images locally"
        info="Download all images and update links to local files"
        {...itemProps.downloadImages}
      />
      
      <Form.Checkbox
        label="Open file after conversion"
        info="Automatically open the markdown file in your default editor"
        {...itemProps.openAfterConversion}
      />
    </Form>
  );
}