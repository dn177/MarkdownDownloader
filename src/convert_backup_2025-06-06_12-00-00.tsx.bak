import {
  Form,
  ActionPanel,
  Action,
  showToast,
  Toast,
  getPreferenceValues,
  LocalStorage,
  showInFinder,
  popToRoot,
} from "@raycast/api";
import { useForm, FormValidation } from "@raycast/utils";
import { useState } from "react";
import fetch from "node-fetch";
import TurndownService from "turndown";
import { JSDOM } from "jsdom";
import { Readability } from "readability";
import * as fs from "fs-extra";
import * as path from "path";
import * as crypto from "crypto";

interface FormValues {
  url: string;
  removeNonContent: boolean;
  downloadImages: boolean;
  outputPath: string;
  filename: string;
}

interface Preferences {
  defaultOutputPath: string;
  removeScripts: boolean;
  removeStyles: boolean;
  removeComments: boolean;
}

export default function ConvertWebpage() {
  const [isLoading, setIsLoading] = useState(false);
  const preferences = getPreferenceValues<Preferences>();

  const { handleSubmit, itemProps } = useForm<FormValues>({
    onSubmit: async (values) => {
      setIsLoading(true);
      try {
        await convertWebpageToMarkdown(values);
      } catch (error) {
        await showToast({
          style: Toast.Style.Failure,
          title: "Conversion Failed",
          message: error instanceof Error ? error.message : "Unknown error",
        });
      } finally {
        setIsLoading(false);
      }
    },
    validation: {
      url: FormValidation.Required,
      outputPath: FormValidation.Required,
      filename: FormValidation.Required,
    },
    initialValues: {
      outputPath: preferences.defaultOutputPath || path.join(process.env.HOME || "", "Downloads"),
      removeNonContent: true,
      downloadImages: true,
    },
  });

  async function convertWebpageToMarkdown(values: FormValues) {
    // Fetch the webpage
    const response = await fetch(values.url, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch webpage: ${response.statusText}`);
    }

    const html = await response.text();
    const baseUrl = new URL(values.url);

    // Parse HTML with JSDOM
    const dom = new JSDOM(html, { url: values.url });
    const document = dom.window.document;

    let content: string;
    let title = document.title || "Untitled";

    if (values.removeNonContent) {
      // Use Readability to extract main content
      const reader = new Readability(document);
      const article = reader.parse();

      if (!article) {
        throw new Error("Failed to extract article content");
      }

      // Create a new document with just the article content
      const cleanDom = new JSDOM(article.content);
      content = await convertToMarkdown(
        cleanDom.window.document.body,
        values,
        baseUrl,
        values.outputPath
      );
      title = article.title || title;
    } else {
      // Convert the entire body
      content = await convertToMarkdown(
        document.body,
        values,
        baseUrl,
        values.outputPath
      );
    }

    // Create output directory if it doesn't exist
    await fs.ensureDir(values.outputPath);

    // Generate filename
    const filename = values.filename.endsWith(".md") 
      ? values.filename 
      : `${values.filename}.md`;
    
    const outputFile = path.join(values.outputPath, filename);

    // Add metadata header
    const metadata = `---
title: ${title}
url: ${values.url}
date: ${new Date().toISOString()}
---

`;

    // Write the markdown file
    await fs.writeFile(outputFile, metadata + content);

    await showToast({
      style: Toast.Style.Success,
      title: "Conversion Complete",
      message: `Saved to ${filename}`,
      primaryAction: {
        title: "Show in Finder",
        onAction: () => {
          showInFinder(outputFile);
        },
      },
    });

    await popToRoot();
  }

  async function convertToMarkdown(
    element: Element,
    values: FormValues,
    baseUrl: URL,
    outputPath: string
  ): Promise<string> {
    // Process images if needed
    if (values.downloadImages) {
      await processImages(element, baseUrl, outputPath);
    }

    // Configure Turndown
    const turndownService = new TurndownService({
      headingStyle: "atx",
      hr: "---",
      bulletListMarker: "-",
      codeBlockStyle: "fenced",
      fence: "```",
      emDelimiter: "_",
      strongDelimiter: "**",
      linkStyle: "inlined",
    });

    // Add custom rules for better conversion
    turndownService.addRule("removeScripts", {
      filter: ["script", "noscript"],
      replacement: () => "",
    });

    turndownService.addRule("removeStyles", {
      filter: ["style"],
      replacement: () => "",
    });

    turndownService.addRule("removeMeta", {
      filter: ["meta", "link"],
      replacement: () => "",
    });

    // Keep code blocks
    turndownService.addRule("codeBlocks", {
      filter: ["pre"],
      replacement: (content, node) => {
        const codeElement = (node as HTMLElement).querySelector("code");
        const language = codeElement?.className.match(/language-(\w+)/)?.[1] || "";
        return `\n\`\`\`${language}\n${content}\n\`\`\`\n`;
      },
    });

    return turndownService.turndown(element);
  }

  async function processImages(element: Element, baseUrl: URL, outputPath: string) {
    const images = element.querySelectorAll("img");
    const imageDir = path.join(outputPath, "images");
    await fs.ensureDir(imageDir);

    for (const img of images) {
      try {
        const src = img.getAttribute("src");
        if (!src) continue;

        const imageUrl = new URL(src, baseUrl);
        
        // Skip data URLs
        if (imageUrl.protocol === "data:") continue;

        // Download image
        const response = await fetch(imageUrl.href);
        if (!response.ok) continue;

        const buffer = await response.buffer();
        
        // Generate unique filename
        const ext = path.extname(imageUrl.pathname) || ".jpg";
        const hash = crypto.createHash("md5").update(imageUrl.href).digest("hex");
        const filename = `${hash}${ext}`;
        const localPath = path.join(imageDir, filename);

        // Save image
        await fs.writeFile(localPath, buffer);

        // Update image src to local path
        img.setAttribute("src", `images/${filename}`);
        
        // Add alt text if missing
        if (!img.getAttribute("alt")) {
          img.setAttribute("alt", path.basename(filename, ext));
        }
      } catch (error) {
        console.error(`Failed to download image: ${error}`);
      }
    }
  }

  return (
    <Form
      isLoading={isLoading}
      actions={
        <ActionPanel>
          <Action.SubmitForm onSubmit={handleSubmit} />
        </ActionPanel>
      }
    >
      <Form.TextField
        title="URL"
        placeholder="https://example.com/article"
        {...itemProps.url}
      />
      <Form.TextField
        title="Filename"
        placeholder="article.md"
        {...itemProps.filename}
      />
      <Form.TextField
        title="Output Path"
        placeholder="/Users/username/Documents"
        {...itemProps.outputPath}
      />
      <Form.Separator />
      <Form.Checkbox
        label="Remove non-content elements (ads, navigation, etc.)"
        {...itemProps.removeNonContent}
      />
      <Form.Checkbox
        label="Download images locally"
        {...itemProps.downloadImages}
      />
    </Form>
  );
}